using System.Linq;
using Content.Shared.Surgery;
using Robust.Client.AutoGenerated;
using Robust.Client.UserInterface.Controls;
using Robust.Client.UserInterface.XAML;
using Content.Client.UserInterface.Controls;
using Robust.Client.Graphics;
using Robust.Shared.Timing;
using Content.Shared.Surgery.Components;
using Robust.Shared.Prototypes;
using System.Numerics;
using Robust.Client.UserInterface;
using Content.Shared.Tools;

namespace Content.Client._Wega.Surgery.Ui;

[GenerateTypedNameReferences]
public sealed partial class SurgeryWindow : FancyWindow
{
    private readonly IPrototypeManager _prototypeManager;

    private readonly StyleBoxFlat _groupButtonStyle = new()
    {
        BackgroundColor = Color.FromHex("#3E3E5C"),
        BorderColor = Color.FromHex("#575B7F"),
        BorderThickness = new Thickness(1)
    };

    private readonly StyleBoxFlat _stepButtonStyle = new()
    {
        BackgroundColor = Color.FromHex("#2E2E3E"),
        BorderColor = Color.FromHex("#45475A"),
        BorderThickness = new Thickness(1)
    };

    private readonly StyleBoxFlat _completedStyle = new()
    {
        BackgroundColor = Color.FromHex("#00FF0020"),
        BorderColor = Color.FromHex("#00FF00")
    };

    public Action<string, int, bool>? OnStepPressed;
    private Button? _selectedGroup;
    private float _animationTime;
    private const float AnimationSpeed = 5f;

    public SurgeryWindow()
    {
        RobustXamlLoader.Load(this);
        IoCManager.InjectDependencies(this);

        _prototypeManager = IoCManager.Resolve<IPrototypeManager>();
    }

    protected override void FrameUpdate(FrameEventArgs args)
    {
        base.FrameUpdate(args);
        _animationTime += args.DeltaSeconds;

        if (_selectedGroup != null)
        {
            var pulse = 0.5f + MathF.Sin(_animationTime * AnimationSpeed) * 0.1f;
            _selectedGroup.Modulate = Color.White.WithAlpha(pulse);
        }
    }

    public void UpdateState(SurgeryProcedureDto state, OperatedComponent comp)
    {
        GroupListContainer.RemoveAllChildren();
        ProtoId<SurgeryNodePrototype>? currentTargetNode = comp.CurrentTargetNode;
        Button? groupToSelect = null;

        foreach (var group in state.Groups)
        {
            var button = new Button
            {
                Text = $"{group.GroupName} {(currentTargetNode == group.TargetNode ? "▶" : "")}",
                ToolTip = group.Description,
                HorizontalExpand = true,
                MinHeight = 32,
                Margin = new Thickness(0, 0, 0, 2),
                StyleBoxOverride = _groupButtonStyle
            };

            button.OnPressed += _ =>
            {
                SelectGroup(button);
                ShowSteps(group, comp);
            };

            GroupListContainer.AddChild(button);

            if (group.TargetNode == currentTargetNode)
            {
                groupToSelect = button;
            }
        }

        if (state.Groups.Count > 0)
        {
            var groupToShow = comp.CurrentNode != "Default"
                ? state.Groups.FirstOrDefault(g => g.TargetNode == comp.CurrentNode)
                : state.Groups[0];

            if (groupToShow != null)
            {
                ShowSteps(groupToShow, comp);
                groupToSelect ??= GroupListContainer.GetChild(state.Groups.IndexOf(groupToShow)) as Button;
            }
        }

        if (groupToSelect != null)
        {
            SelectGroup(groupToSelect);
        }
    }

    private void SelectGroup(Button button)
    {
        if (_selectedGroup != null)
        {
            _selectedGroup.StyleBoxOverride = _groupButtonStyle;
            _selectedGroup.Modulate = Color.White;
        }

        button.StyleBoxOverride = new StyleBoxFlat
        {
            BackgroundColor = Color.FromHex("#575B7F"),
            BorderColor = Color.FromHex("#6F76B8"),
            BorderThickness = new Thickness(1)
        };

        _selectedGroup = button;
        _animationTime = 0f;
    }

    private void ShowSteps(SurgeryGroupDto group, OperatedComponent comp)
    {
        StepListContainer.RemoveAllChildren();
        var visibleSteps = group.Steps.Where(s => s.IsVisible).ToList();

        var firstEnabledNonParallelStep = visibleSteps.FirstOrDefault(s =>
            s.IsEnabled && !s.IsCompleted && !s.Name.Contains(Loc.GetString("surgery-parallel")));

        foreach (var stepDto in visibleSteps)
        {
            var statusIcon = stepDto.IsCompleted ? "✓" : stepDto.IsEnabled ? "→" : "✗";
            var stepText = $"{statusIcon} {stepDto.Name}";

            var isStepActive = stepDto.IsEnabled && !stepDto.IsCompleted &&
                (stepDto.Name.Contains(Loc.GetString("surgery-parallel")) || stepDto == firstEnabledNonParallelStep);

            var stepButton = new Button
            {
                Text = stepText,
                Disabled = !isStepActive,
                ToolTip = GetStepTooltip(stepDto),
                StyleBoxOverride = stepDto.IsCompleted ? _completedStyle : _stepButtonStyle,
                HorizontalExpand = true
            };

            if (!string.IsNullOrEmpty(stepDto.RequiredTool))
            {
                var toolContainer = new BoxContainer
                {
                    Orientation = BoxContainer.LayoutOrientation.Horizontal,
                    HorizontalExpand = true,
                    Children =
                    {
                        CreateToolIcon(stepDto.RequiredTool)
                    }
                };

                stepButton.AddChild(toolContainer);
            }

            stepButton.OnPressed += _ =>
            {
                OnStepPressed?.Invoke(
                    group.TargetNode,
                    group.Steps.IndexOf(stepDto),
                    stepDto.Name.Contains(Loc.GetString("surgery-parallel"))
                );
            };

            StepListContainer.AddChild(stepButton);
        }
    }

    private Control CreateToolIcon(string toolQualityId)
    {
        var container = new BoxContainer
        {
            MinSize = new Vector2(32, 32),
            MaxSize = new Vector2(32, 32),
            Margin = new Thickness(4)
        };

        if (_prototypeManager.TryIndex<ToolQualityPrototype>(toolQualityId, out var toolQuality) &&
            _prototypeManager.TryIndex<EntityPrototype>(toolQuality.Spawn, out var toolProto))
        {
            var icon = new EntityPrototypeView
            {
                Scale = new Vector2(1, 1),
                SetSize = new Vector2(32, 32),
                OverrideDirection = Direction.South,
                Margin = new Thickness(2)
            };
            icon.SetPrototype(toolProto.ID);
            container.AddChild(icon);
        }
        else
        {
            container.AddChild(new Label { Text = "?" });
        }

        return container;
    }

    private string GetStepTooltip(SurgeryStepDto step)
    {
        var tooltip = "";
        if (!string.IsNullOrEmpty(step.RequiredTool))
            tooltip += $"{Loc.GetString("surgery-tool-required", ("tool", step.RequiredTool))}\n";
        if (!string.IsNullOrEmpty(step.RequiredCondition))
            tooltip += Loc.GetString("surgery-condition-required", ("condition", step.RequiredCondition));
        return tooltip.Trim();
    }
}